/*
*  Copyright (C) 2013 The OmniROM Project
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*
*/

package com.android.settings.beanstalk.backup;

import android.app.backup.IBackupManager;
import android.app.Notification;
import android.app.Service;
import android.content.ContentResolver;
import android.content.Context;
import android.content.Intent;
import android.content.pm.PackageInfo;
import android.content.pm.PackageManager;
import android.content.SharedPreferences;
import android.database.Cursor;
import android.net.Uri;
import android.os.Binder;
import android.os.Environment;
import android.os.IBinder;
import android.os.ParcelFileDescriptor;
import android.os.RemoteException;
import android.os.ServiceManager;
import android.preference.PreferenceManager;
import android.provider.DocumentsContract;
import android.provider.DocumentsProvider;
import android.provider.OpenableColumns;
import android.util.Log;
import android.widget.Toast;

import com.android.settings.R;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileDescriptor;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
* Lists and creates application backups.
*
* Backups are created and restored using the system backup service, and  are in the same format
* used by adb backup and adb restore.
*
* All backups are stored in and retrieved from the directory specified by the Uri in
* backup_location.
*
* The number of backups per package is limited by the shared preference backup_history, which
* can be changed in SecuritySettings.
*
* See {@link Backup} for the naming convention for backup files.
*
*/
public class BackupService extends Service {

    private static final String TAG = "BackupService";

    /**
    * The system backup service that does the actual backup/restore work.
    */
    private static IBackupManager mSystemBackupService = IBackupManager.Stub.asInterface(
            ServiceManager.getService(Context.BACKUP_SERVICE));

    /**
    * Name of the folder where backups are stored by default, on the primary external storage.
    */
    private static final String DEFAULT_BACKUP_FOLDER = "BeanStalkBackup";

    /**
    * Id of the notifications generated by this class, should be unique within the settings app.
    */
    private static final int NOTIFICATION_ID_MOVE   = 146;
    private static final int NOTIFICATION_ID_DELETE = 147;

    /**
    * Hardcoded name of the authority for
    * {@link com.android.externalstorage.ExternalStorageProvider}, as this class can't be
    * included from here.
    */
    private static final String EXTERNAL_STORAGE_PROVIDER_AUTHORITY =
            "com.android.externalstorage.documents";

    public class BackupServiceBinder extends Binder {
        public BackupService getService() {
            return BackupService.this;
        }
    }

    private final IBinder mBinder = new BackupServiceBinder();

    private ContentResolver mContentResolver;

    @Override
    public void onCreate() {
        mContentResolver = getContentResolver();
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        return START_NOT_STICKY;
    }

    @Override
    public IBinder onBind(Intent intent) {
        return mBinder;
    }

    /**
    * Observer for {@link #listBackups(List<String>, ListBackupsObserver)}.
    */
    public interface ListBackupsObserver {
        public void onListBackupsCompleted(Map<String, List<Backup>> backups);
    }

    /**
    * Observer for {@link #createBackup(String, CreateBackupObserver)}.
    */
    public interface CreateBackupObserver {
        public void onCreateBackupCompleted();
    }

    /**
    * Observer for {@link #restoreBackup(Backup, RestoreBackupObserver)}.
    */
    public interface RestoreBackupObserver {
        public void onRestoreBackupCompleted();
    }

    /**
    * Observer for {@link #deleteBackup(Backup, DeleteBackupObserver)}.
    */
    public interface DeleteBackupObserver {
        public void onDeleteBackupCompleted();
    }

    /**
    * Deletes the oldest backup(s), so that at most backup_history number
    * of backups exist.
    */
    public class TrimBackupHistory implements ListBackupsObserver {
        @Override
        public void onListBackupsCompleted(Map<String, List<Backup>> backups) {
            int backup_history = PreferenceManager
                    .getDefaultSharedPreferences(BackupService.this)
                    .getInt("backup_history",
                    getResources().getInteger(R.integer.backup_history_default));

            for (String s : backups.keySet()) {
                for (int i = backups.get(s).size() - 1; i >= backup_history; i--) {
                    deleteBackup(backups.get(s).get(i), null);
                }
            }
        }
    }

    /**
    * Compares backups by date so the newest backup comes first.
    */
    private class BackupComparator implements Comparator<Backup> {
        @Override
        public int compare(Backup lhs, Backup rhs) {
            return rhs.date.compareTo(lhs.date);
        }
    }

    /**
    * Lists all backups for the specified packages.
    *
    * Backups are sorted newest backup first.
    *
    * The map of backups returned through observer contains a valid List object for each
    * package name in {@code packageNames}.
    *
    * @param packageNames List of packages for which backups should be listed. If
    * 						this is null, all backups are listed.
    * @param observer Object to be called with the backups. If no backups are found,
    *                 this won't be called.
    */
    public void listBackups(final List<String> packageNames, final ListBackupsObserver observer) {
        new Thread(new Runnable() {

            @Override
            public void run() {
                Uri childs = DocumentsContract.buildChildDocumentsUri(
                        getBackupLocation().getAuthority(),
                        DocumentsContract.getDocumentId(getBackupLocation()));
                Map<String, List<Backup>> backups = new HashMap<String, List<Backup>>();
                // Make sure all requested keys exist.
                if (packageNames != null) {
                    for (String p : packageNames) {
                        backups.put(p, new ArrayList<Backup>());
                    }
                }

                Cursor cursor = mContentResolver.query(childs,
                        new String[]{OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE},
                        null, null, null);
                while (cursor.moveToNext()) {
                    String fileName = cursor.getString(cursor.getColumnIndex(
                            OpenableColumns.DISPLAY_NAME));
                    // FIXME: Workaround as where clause "name = %.ab" has no effect with query.
                    if (!fileName.endsWith(Backup.BACKUP_FILE_TYPE))
                        continue;

                    String[] split = fileName.replace(Backup.BACKUP_FILE_TYPE, "").split("-", 2);
                    if (split.length == 2 && (packageNames == null ||
                            packageNames.contains(split[0]))) {
                        String packageName = split[0];
                        long timestamp = Long.parseLong(split[1]);
                        long size = cursor.getLong(cursor.getColumnIndex(OpenableColumns.SIZE));

                        Uri info = getFile(getBackupLocation(),
                                fileName.replace(Backup.BACKUP_FILE_TYPE, Backup.INFO_FILE_TYPE));
                        String label = packageName;
                        String versionName =
                                getResources().getString((android.R.string.unknownName));
                        if (documentExists(info)) {
                            try {
                                BufferedReader br = new BufferedReader(new InputStreamReader(
                                        mContentResolver.openInputStream(info)));
                                String line;
                                while ((line = br.readLine()) != null) {
                                    String[] keyValue = line.split(":", 2);
                                    if (keyValue[0].equals(Backup.KEY_LABEL)) {
                                        label = keyValue[1].trim();
                                    } else if (keyValue[0].equals(Backup.KEY_VERSION_NAME)) {
                                        versionName = keyValue[1].trim();
                                    }
                                }
                                br.close();
                            } catch (IOException e) {
                                Log.w("Failed to read info from " + info.toString(), e);
                            }
                        }

                        if (!backups.containsKey(packageName)) {
                            backups.put(packageName, new ArrayList<Backup>());
                        }
                        backups.get(packageName).add(new Backup(
                                packageName, fileName, timestamp, size, label, versionName));
                    }
                }
                cursor.close();

                for (String s : backups.keySet()) {
                    Collections.sort(backups.get(s), new BackupComparator());
                }
                observer.onListBackupsCompleted(backups);
            }
        }).run();
    }

    /**
    * Creates a new backup for the specified package and and saves it to backup_location.
    */
    public void createBackup(final String packageName, final CreateBackupObserver observer) {
        new Thread(new Runnable() {

            @Override
            public void run() {
                try {
                    Log.i(TAG, "Backing up " + packageName);

                    long timestamp = System.currentTimeMillis();
                    Uri backup = DocumentsContract.createDocument(mContentResolver,
                            getBackupLocation(), "application/octet-stream",
                            packageName + "-" + Long.toString(timestamp) +
                            Backup.BACKUP_FILE_TYPE);
                    ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(backup, "w");
                    mSystemBackupService.fullBackup(pfd, true, false,
                            false, false, false, new String[]{packageName});

                    Uri info = DocumentsContract.createDocument(mContentResolver,
                            getBackupLocation(), "application/octet-stream",
                            packageName + "-" + Long.toString(timestamp) + Backup.INFO_FILE_TYPE);
                    PackageManager pm = getPackageManager();
                    PackageInfo pInfo = pm.getPackageInfo(packageName, 0);

                    // NOTE: This stores the localized label and version name, which might be
                    // noticable when restoring to a different language device. On the other
                    // hand, label and version name probably aren't localized most of the time.
                    OutputStreamWriter osw =
                            new OutputStreamWriter(mContentResolver.openOutputStream(info));
                    String label = Backup.KEY_LABEL + ": " +
                            pm.getApplicationLabel(pInfo.applicationInfo) + "\n";
                    osw.write(label, 0, label.length());
                    String version = Backup.KEY_VERSION_NAME + ": " + pInfo.versionName + "\n";
                    osw.write(version, 0, version.length());
                    osw.close();

                    listBackups(Arrays.asList(packageName), new TrimBackupHistory());
                    observer.onCreateBackupCompleted();
                } catch (FileNotFoundException e) {
                    Log.w(TAG, "Backup failed for " + packageName, e);
                } catch (RemoteException e) {
                    Log.w(TAG, "Backup failed for " + packageName, e);
                } catch (IOException e) {
                    Log.w(TAG, "Backup failed for " + packageName, e);
                } catch (PackageManager.NameNotFoundException e) {
                    Log.w(TAG, "Could not read app info to store with backup for " +
                            packageName, e);
                }
            }
        }).run();
    }

    /**
    * Restores a backup that was previously retrieved using listBackups and is
    * located in the backup folder;
    */
    public void restoreBackup(final Backup b, final RestoreBackupObserver observer) {
        new Thread(new Runnable() {

            @Override
            public void run() {
                try {
                    Log.i(TAG, "Restoring backup " + b.fileName);

                    ParcelFileDescriptor pfd = mContentResolver.openFileDescriptor(
                            Uri.withAppendedPath(getBackupLocation(), b.fileName), "r");
                    mSystemBackupService.fullRestore(pfd);
                    if (observer != null) {
                        observer.onRestoreBackupCompleted();
                    }
                } catch (FileNotFoundException e) {
                    Log.w(TAG, "Restore failed for " + b.fileName, e);
                } catch (RemoteException e) {
                    Log.w(TAG, "Restore failed for " + b.fileName, e);
                } catch (IOException e) {
                    Log.w(TAG, "Restore failed for " + b.fileName, e);
                }
            }
        }).run();
    }

    /**
    * Moves all files located in folder {@code from} to folder {@code to}. {@code from} is
    * deleted after moving all files.
    *
    * A notification is displayed to prevent the service from being killed during the operation.
    */
    public void moveBackups(final Uri from, final Uri to) {
        new Thread(new Runnable() {

            @Override
            public void run() {
                Notification.Builder builder = new Notification.Builder(BackupService.this)
                        .setOngoing(true)
                        .setContentTitle(getString(R.string.backup_notification_moving))
                        .setProgress(0, 0, true);
                startForeground(NOTIFICATION_ID_MOVE, builder.build());
                Log.i(TAG, "Moving all backups from " + from.toString() +
                        " to " + to.toString());

                Uri childs = DocumentsContract.buildChildDocumentsUri(from.getAuthority(),
                        DocumentsContract.getDocumentId(from));
                Cursor cursor = mContentResolver.query(childs,
                        new String[]{OpenableColumns.DISPLAY_NAME,
                        DocumentsContract.Document.COLUMN_MIME_TYPE}, null, null, null);
                while (cursor.moveToNext()) {
                    String fileName = cursor.getString(cursor.getColumnIndex(
                            OpenableColumns.DISPLAY_NAME));
                    String mime = cursor.getString(cursor.getColumnIndex(
                            DocumentsContract.Document.COLUMN_MIME_TYPE));
                    Uri inUri = getFile(from, fileName);
                    Uri outUri = DocumentsContract.createDocument(mContentResolver, to, mime,
                            fileName);
                    InputStream is = null;
                    OutputStream os = null;
                    try {

                        is = mContentResolver.openInputStream(inUri);
                        os = mContentResolver.openOutputStream(outUri);

                        byte[] buffer = new byte[1024];
                        int len;
                        while ((len = is.read(buffer)) != -1) {
                            os.write(buffer, 0, len);
                        }

                        DocumentsContract.deleteDocument(mContentResolver, inUri);
                        startForeground(NOTIFICATION_ID_MOVE, builder.setProgress(
                                cursor.getPosition(), cursor.getCount() - 1, false).build());
                    } catch (FileNotFoundException e) {
                        Log.w(TAG, "Failed to move backups", e);
                    } catch (IOException e) {
                        Log.w(TAG, "Failed to move backups", e);
                    } finally {
                        try {
                            if (is != null) {
                                is.close();
                            }
                            if (os != null) {
                                os.close();
                            }
                        } catch (IOException e) {
                        }
                    }
                }
                DocumentsContract.deleteDocument(mContentResolver, from);
                cursor.close();
                stopForeground(true);
            }
        }).run();
    }

    /**
    * Deletes the specified backup from the backup folder.
    *
    * A notification is displayed to prevent the service from being killed during the operation.
    */
    public void deleteBackup(final Backup b, final DeleteBackupObserver observer) {
        new Thread(new Runnable() {

            @Override
            public void run() {
                Notification.Builder builder = new Notification.Builder(BackupService.this)
                        .setOngoing(true)
                        .setContentTitle(getString(R.string.backup_notification_deleting))
                        .setProgress(0, 0, true);
                startForeground(NOTIFICATION_ID_DELETE, builder.build());
                Log.i(TAG, "Deleting backup " + b.fileName);

                boolean success = DocumentsContract.deleteDocument(mContentResolver,
                        getFile(getBackupLocation(), b.fileName));
                String infoFileName =
                        b.fileName.replace(Backup.BACKUP_FILE_TYPE, Backup.INFO_FILE_TYPE);
                // Don't check success for the info file, as it may not exist, and if the
                // backup is deleted, this is probably deleted, too.
                DocumentsContract.deleteDocument(mContentResolver,
                        getFile(getBackupLocation(), infoFileName));
                if (success && observer != null) {
                    observer.onDeleteBackupCompleted();
                }
                stopForeground(true);
            }
        }).run();
    }

    /**
    * Returns Uri of the folder currently set in backup_location.
    *
    * If the folder specified has not been set or has been
    * deleted, {@code DEFAULT_BACKUP_FOLDER} is created on the primary external
    * storage and returned.
    */
    public Uri getBackupLocation() {
        SharedPreferences prefs = PreferenceManager
                .getDefaultSharedPreferences(this);
        Uri location = Uri.parse(prefs.getString("backup_location", ""));

        {
            Uri roots = DocumentsContract.buildRootsUri(EXTERNAL_STORAGE_PROVIDER_AUTHORITY);
            Cursor cursor = mContentResolver.query(roots,
                    new String[]{DocumentsContract.Root.COLUMN_DOCUMENT_ID}, null, null, null);
            cursor.moveToFirst();
            String rootId = cursor.getString(cursor.getColumnIndex(
                    DocumentsContract.Root.COLUMN_DOCUMENT_ID));
            cursor.close();
            Uri root = DocumentsContract.buildDocumentUri(
                    EXTERNAL_STORAGE_PROVIDER_AUTHORITY, rootId);
        }


        if (location.equals(Uri.EMPTY) || !documentExists(location)) {
            Uri roots = DocumentsContract.buildRootsUri(EXTERNAL_STORAGE_PROVIDER_AUTHORITY);
            Cursor cursor = mContentResolver.query(roots,
                    new String[]{DocumentsContract.Root.COLUMN_DOCUMENT_ID}, null, null, null);
            cursor.moveToFirst();
            String rootId = cursor.getString(cursor.getColumnIndex(
                    DocumentsContract.Root.COLUMN_DOCUMENT_ID));
            cursor.close();
            Uri root = DocumentsContract.buildDocumentUri(
                    EXTERNAL_STORAGE_PROVIDER_AUTHORITY, rootId);
            Uri backupFolder = (documentExists(getFile(root, DEFAULT_BACKUP_FOLDER)))
                    ? getFile(root, DEFAULT_BACKUP_FOLDER)
                    : DocumentsContract.createDocument(mContentResolver, root,
                            DocumentsContract.Document.MIME_TYPE_DIR, DEFAULT_BACKUP_FOLDER);

            if (backupFolder == null || !documentExists(backupFolder)) {
                Log.e(TAG, "Failed to create backupfolder, aborting");
                return null;
            }

            prefs.edit()
                    .putString("backup_location", backupFolder.toString())
                    .apply();
            Log.w(TAG, "Backup location is not set or deleted, using default: " +
                    backupFolder.toString());
            Toast.makeText(this,
                    getString(R.string.backup_location_missing, backupFolder.toString()),
                    Toast.LENGTH_LONG)
                    .show();
        }
        return location;
    }

    /**
    * Workaround for {link Uri.withAppendedPath(Uri, String)},
    * which apparently does not escape the last '/' properly.
    *
    * TODO: replace this with Uri.withAppendedPath if possible
    */
    private Uri getFile(Uri folder, String fileName) {
        return Uri.parse(folder + "%2F" + fileName);
    }

    /**
    * Returns true if the document represented by {@code uri} exists in a {@link ContentProvider}.
    */
    private boolean documentExists(Uri uri) {
        if (!DocumentsContract.isDocumentUri(this, uri)) {
            return false;
        }

        Cursor cursor = mContentResolver.query(uri, new String[]{}, null, null, null);
        if (cursor == null) {
            return false;
        } else {
            cursor.close();
            return true;
        }
    }

}
